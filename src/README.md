# Python USB-CAN DJI 电机控制系统

## 1\. 项目概述

本项目实现了一个基于 Python 的闭环电机控制系统，通过 USB 转 CAN 模块控制 DJI GM6020 无刷电机（兼容 M3508/M2006，需修改参数）。系统采用 **串级 PID（位置环 + 速度环）** 架构，实现了精准的角度控制和静止死区优化。

### 核心特性

  * **模块化设计**：驱动、协议、算法、逻辑分离。
  * **多电机支持**：基于对象封装，轻松扩展 1-8 个电机。
  * **双环 PID**：外环位置控制 + 内环速度控制。
  * **死区优化**：消除稳态微小震荡。
  * **协议适配**：适配达妙（Damiao）类 USB-CAN 模块的特定帧格式。

-----

## 2\. 文件结构

```text
.
├── main.py           # [入口] 主程序，定义关节、管理循环、发送指令
├── can_driver.py     # [驱动] 处理 USB 串口原始数据的收发、分包、拼包
├── dji_motor.py      # [协议] 处理 DJI 电机协议 (物理量 <-> 原始字节)
├── pid.py            # [算法] 通用 PID 类，支持限幅、死区
└── README.md         # 项目说明文档
```

-----

## 3\. 通信协议说明 (关键)

本项目使用的 USB-CAN 模块具有特定的串口封装格式，**不同于标准的 SocketCAN**。

### 3.1 接收协议 (USB -\> PC)

这是我们通过调试反推出来的格式，模块回传数据为 **16 字节定长**。

| 字节偏移 | 值/内容 | 说明 |
| :--- | :--- | :--- |
| 0 | **0xAA** | 帧头 |
| 1 | 0x11 | 状态字 |
| 2 | 0x08 | 数据长度 (DLC) |
| 3-6 | **CAN ID** | 小端模式 (Little Endian) |
| 7-14 | **Payload** | 8字节 CAN 数据 (电机反馈) |
| 15 | **0x55** | 帧尾 |

### 3.2 发送协议 (PC -\> USB)

发送需要封装为 **30 字节定长** 格式。

| 字节偏移 | 值/内容 | 说明 |
| :--- | :--- | :--- |
| 0 | **0x55** | 帧头1 |
| 1 | **0xAA** | 帧头2 |
| 2 | 0x1E | 总长度 (30字节) |
| 3 | 0x01 | 发送命令 |
| 4-12 | ... | 计数、间隔、ID类型 (通常填0或1) |
| 13-16 | **CAN ID** | 小端模式 (Little Endian) |
| 17-20 | ... | 帧类型、DLC 等 |
| 21-28 | **Payload** | 8字节 CAN 数据 (控制指令) |
| 29 | 0x88 | 校验/尾部 |

-----

## 4\. DJI 电机 ID 映射表

DJI 电机的 CAN ID 并不连续，且不同型号有差异。本项目目前配置为 **GM6020**。

### GM6020 (电压控制模式)

  * **控制 ID (发送)**:
      * ID 1-4: 使用 `0x1FF` (数据填入对应字节)
      * ID 5-7: 使用 `0x2FF`
  * **反馈 ID (接收)**:
      * 电机 ID 1 -\> CAN ID `0x205`
      * 电机 ID 2 -\> CAN ID `0x206`
      * ...

*(注：如果是 M3508/2006，控制 ID 通常为 0x200 和 0x1FF，反馈从 0x201 开始。需在 `dji_motor.py` 中调整)*

-----

## 5\. 如何扩展 (添加更多电机)

本系统已重构为面向对象模式，添加电机非常简单。

### 步骤 1: 硬件连接与拨码

确保新电机的拨码开关已正确设置（例如设置为 ID 2），并连接到 CAN 总线。

### 步骤 2: 修改 `main.py`

在 `joints` 字典中添加一行代码即可：

```python
# ... 现有代码 ...

# 添加 1 号电机 (Yaw)
joints[1] = GimbalJoint(motor_id=1, target_angle=90.0)

# === 新增：添加 2 号电机 (例如 Pitch) ===
# 假设 Pitch 轴需要更硬的 PID 参数
joints[2] = GimbalJoint(motor_id=2, target_angle=0.0) 

# 如果需要为特定电机单独调整 PID：
# joints[2].angle_pid.kp = 80.0
# joints[2].speed_pid.ki = 5.0

# ...
```

系统会自动处理以下逻辑：

1.  自动识别 ID 2 的反馈数据 (`0x206`)。
2.  自动计算 PID。
3.  自动将控制数据拼接到 `0x1FF` 帧的第 2、3 字节（Index 2, 3）。

-----

## 6\. 参数调试指南

如果更换负载或电机，可能需要调整 `main.py` 或 `GimbalJoint` 类中的 PID 参数。

### 速度环 (内环) `speed_pid`

  * **Kp**: 决定电机的爆发力。太小转不动，太大电机嗡嗡响（高频震荡）。
  * **Ki**: **关键**。用于消除稳态误差和克服静摩擦力。如果电机在目标附近卡住不动，增大 Ki。
  * **Dead Zone**: 速度环通常设为 0 或极小值。

### 角度环 (外环) `angle_pid`

  * **Kp**: 决定响应速度。太小跟随慢，太大并在目标处“画圆”震荡（低频震荡）。
  * **Dead Zone**: **关键**。设置为 `0.3` - `0.5` 度。当误差小于此值时，强制输出 0，让电机完全静止并降温。

### 常见问题排查

| 现象 | 原因 | 解决方法 |
| :--- | :--- | :--- |
| **电机疯转 (飞车)** | 反馈方向与控制方向相反 | 在 `GimbalJoint.update` 中修改 `output = -raw_output` (取反)。 |
| **电机不动，Out有值** | 动力不足或摩擦力大 | 增大速度环 `Ki`，或增大电压限幅 `out_max`。 |
| **目标处来回抖动** | 缺乏死区或 Kp 过大 | 增大角度环 `dead_zone`，或减小角度环 `Kp`。 |
| **报错 Permission denied** | 串口权限不足 | 执行 `sudo chmod 777 /dev/ttyACM0`。 |
| **解析乱码** | 接收对齐错误 | 检查 `can_driver.py` 是否严格校验了 `0xAA ... 0x55`。 |

-----

## 7\. 快速开始

1.  **连接硬件**：插入 USB-CAN，连接电机电源。
2.  **赋权**：
    ```bash
    sudo chmod 777 /dev/ttyACM0
    ```
3.  **运行**：
    ```bash
    python3 main.py
    ```
4.  **观察**：
    终端将输出类似如下信息：
    ```text
    [ID1] Tgt:90.0 Real:89.8 Out:0 | [ID2] Tgt:0.0 Real:0.1 Out:0 |
    ```

-----

### 附录：核心代码逻辑图

```mermaid
graph TD
    A[main.py 循环] --> B{遍历所有关节 GimbalJoint}
    B --> C[读取当前 Angle/RPM]
    C --> D[角度环 PID]
    D -->|输出目标速度| E[速度环 PID]
    E -->|输出电压| F[取反/限幅]
    F --> G[生成 2Byte 控制数据]
    G --> H[拼装 CAN 帧 (0x1FF)]
    H --> I[CANDriver 发送 USB 报文]
    I --> J[电机执行]
    J -->|CAN 反馈| K[CANDriver 接收解析]
    K -->|更新状态| C
```



